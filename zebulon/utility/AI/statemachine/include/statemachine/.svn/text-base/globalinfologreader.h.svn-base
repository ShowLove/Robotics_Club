/////////////////////////////////////////////////////////////////////////////
///
///  \file globalinfologreader.h
///  \brief Software to read log data generated by GlobalInfo.
///
///  Author(s): Daniel Barber<br>
///  Created: 2010<br>
///  Copyright (c) 2010<br>
///  Robotics Laboratory and Club<br>
///  University of Central Florida (UCF) <br>
///  Email: dbarber@ist.ucf.edu<br>
///  Web: http://robotics.ucf.edu <br>
///  All Rights Reserved <br>
///
///  Redistribution and use in source and binary forms, with or without
///  modification, are permitted provided that the following conditions are met:
///      * Redistributions of source code must retain the above copyright
///        notice, this list of conditions and the following disclaimer.
///      * Redistributions in binary form must reproduce the above copyright
///        notice, this list of conditions and the following disclaimer in the
///        documentation and/or other materials provided with the distribution.
///      * Neither the name of the ROBOTICS CLUB AT UCF, UCF, nor the
///        names of its contributors may be used to endorse or promote products
///        derived from this software without specific prior written permission.
///
///  THIS SOFTWARE IS PROVIDED BY THE ROBOTICS CLUB AT UCF ''AS IS'' AND ANY
///  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
///  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
///  DISCLAIMED. IN NO EVENT SHALL UCF BE LIABLE FOR ANY
///  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
///  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
///  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
///  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
///  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
///  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
///
////////////////////////////////////////////////////////////////////////////////////
#ifndef __ZEBULON_STATEMACHINE_AI_GLOBAL_INFO_LOG_READER__H
#define __ZEBULON_STATEMACHINE_AI_GLOBAL_INFO_LOG_READER__H

#include <cxutils/thread.h>
#include "statemachine/globalinfo.h"

namespace Zebulon
{
    namespace AI
    {
        ////////////////////////////////////////////////////////////////////////////////////
        ///
        ///  \class GlobalInfoLogReader
        ///  \brief Class designed to read in data generated during logging by a
        ///         GlobalInfo object.
        ///
        ///  Given a directory containing log data, files, images, and other data is read
        ///  in a thread, and saved to a GlobalInfo object.
        ///
        ////////////////////////////////////////////////////////////////////////////////////
        class ZEB_STATEMACHINE_UTIL_DLL  GlobalInfoLogReader
        {
        public:
            // Constructor.
            GlobalInfoLogReader(const bool loop = true);
            // Destructor.
            ~GlobalInfoLogReader();
            // Set global info object to write to.
            bool SetGlobalInfo(GlobalInfo* globalInfo);
            // Set directory to read log data from, and start reading with thread.
            bool Initialize(const std::string& directory);
            // Set's the playback rate, default is 1x
            void SetPlaybackRate(const int rate);
            // Set a timestamp to skip to.
            void SetLogStartTime(const CxUtils::Time& startTime);
            // Stop reading data from logs.
            void Shutdown();
            // Method to pause/resume playback.
            void Pause(const bool enable) { mPauseFlag = enable; }
            // Check if we are paused.
            bool IsPaused() const { return mPauseFlag; }
            // Get the current log time.
            CxUtils::Time GetLogTime() const { CxUtils::Mutex::ScopedLock lock(&mLogMutex); return mLogTime; }
            // Overload method to read extra data that is custom for some Global Info data structures.
            virtual bool ReadAdditionalData(const std::string& fieldName, const std::string& dataString) { return true; }
            // Method to disable playback of LIDAR data
            void DisablePointPlayback(const bool value = true) { mDisableLidarPlaybackFlag = value; }
        protected:
            static void DataReaderThread(void* args);
            static void LaserReaderThread(void* args);
            volatile bool mPauseFlag;           ///<  If true, pause data reading.
            volatile bool mRewindFlag;          ///<  Rewind flag.
            volatile unsigned int mRewindThreadCount;    ///<  Counter for threads ready.
            bool mLoopData;                     ///<  If true, loop data reading.
            int mLogVersionNumber;              ///<  Log file version number.
            int mLidarLogVersionNumber;         ///<  Log version number for LIDAR data.
            GlobalInfo* mpGlobalInfo;           ///<  Where to save read data to.
            CxUtils::Thread mDataReaderThread;  ///<  Thread to read data from log.
            CxUtils::Thread mLaserReaderThread; ///<  Thread to read laser data.
            CxUtils::Mutex mLogMutex;           ///<  Mutex for thread protection.
            CxUtils::Time mLogTime;             ///<  Current time in the log.
            CxUtils::Time mLogStartTime;        ///<  Log start time.
            CxUtils::Time mPlaybackDelayMs;     ///<  Playback delay time ms.
            std::string mDirectory;             ///<  Directory to read data from.
            std::string mDataLogFile;           ///<  Data log file name.
            std::string mLidarLogFile;          ///<  LIDAR data log file name.
            bool mDisableLidarPlaybackFlag;     ///<  Disable playback of LIDAR data.
            int mPlaybackRate;                  ///<  Playback rate in 1x, 2x, etc.
        };
    }
}


#endif
/* End of File */
