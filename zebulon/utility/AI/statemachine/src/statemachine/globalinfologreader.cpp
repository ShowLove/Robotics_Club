/////////////////////////////////////////////////////////////////////////////
///
///  \file globalinfologreader.cpp
///  \brief Software to read log data generated by GlobalInfo.
///
///  Author(s): Daniel Barber<br>
///  Created: 2010<br>
///  Copyright (c) 2010<br>
///  Robotics Laboratory and Club<br>
///  University of Central Florida (UCF) <br>
///  Email: dbarber@ist.ucf.edu<br>
///  Web: http://robotics.ucf.edu <br>
///  All Rights Reserved <br>
///
///  Redistribution and use in source and binary forms, with or without
///  modification, are permitted provided that the following conditions are met:
///      * Redistributions of source code must retain the above copyright
///        notice, this list of conditions and the following disclaimer.
///      * Redistributions in binary form must reproduce the above copyright
///        notice, this list of conditions and the following disclaimer in the
///        documentation and/or other materials provided with the distribution.
///      * Neither the name of the ROBOTICS CLUB AT UCF, UCF, nor the
///        names of its contributors may be used to endorse or promote products
///        derived from this software without specific prior written permission.
///
///  THIS SOFTWARE IS PROVIDED BY THE ROBOTICS CLUB AT UCF ''AS IS'' AND ANY
///  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
///  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
///  DISCLAIMED. IN NO EVENT SHALL UCF BE LIABLE FOR ANY
///  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
///  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
///  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
///  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
///  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
///  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
///
////////////////////////////////////////////////////////////////////////////////////
#include "statemachine/globalinfologreader.h"
#include <cxutils/fileio.h>
#include <algorithm>
#include <iostream>
#include <iomanip>

using namespace Zebulon;
using namespace AI;


////////////////////////////////////////////////////////////////////////////////////
///
///   \brief Constructor.
///
///   \param[in] loopFlag If true, restart when end reached.
///
////////////////////////////////////////////////////////////////////////////////////
GlobalInfoLogReader::GlobalInfoLogReader(const bool loopFlag) : mLoopData(loopFlag)
{
    mpGlobalInfo = NULL;
    mPauseFlag = false;
    mLogVersionNumber = 2;
    mLidarLogVersionNumber = 2;
    mPlaybackDelayMs = 1;
    mRewindFlag = false;
    mDisableLidarPlaybackFlag = false;
    mPlaybackRate = 1;
}


////////////////////////////////////////////////////////////////////////////////////
///
///   \brief Destructor.
///
////////////////////////////////////////////////////////////////////////////////////
GlobalInfoLogReader::~GlobalInfoLogReader()
{
    Shutdown();
}


////////////////////////////////////////////////////////////////////////////////////
///
///   \brief Sets a pointer to the global information store so data read
///          can be inserted.
///
///   You must call this before starting data playback.
///
///   \param[in] globalInfo Pointer to global information structure.
///
///   \return False on success, true on failure.
///
////////////////////////////////////////////////////////////////////////////////////
bool GlobalInfoLogReader::SetGlobalInfo(GlobalInfo* globalInfo)
{
    if(mDataReaderThread.IsThreadActive() == false)
    {
        mpGlobalInfo = globalInfo;
        return true;
    }
    return false;
}


////////////////////////////////////////////////////////////////////////////////////
///
///   \brief Initializes log playback from  a directory storing logs.
///
///   \param[in] directory Data directory to read from.
///
///   \return True on success, false on failure.
///
////////////////////////////////////////////////////////////////////////////////////
bool GlobalInfoLogReader::Initialize(const std::string& directory)
{
    bool result = false;
    std::vector<std::string> files;
    std::vector<std::string> directories;
    mDirectory = directory;
    if(CxUtils::FileIO::GetFiles(files, "*.csv", directory, false, false))
    {
        for(unsigned int i = 0;
            i < (unsigned int)files.size();
            i++)
        {
            if(mDataLogFile.empty() == false && mLidarLogFile.empty() == false)
            {
                break;
            }
            if(strstr(files[i].c_str(), "global_info_log_v2") != NULL)
            {
                mDataLogFile = files[i];
                mLogVersionNumber = 2;
                continue;
            }
            if(strstr(files[i].c_str(), "global_info_log") != NULL)
            {
                mDataLogFile = files[i];
                mLogVersionNumber = 1;
                continue;
            }
            if(strstr(files[i].c_str(), "global_info_lidar_v2") != NULL)
            {
                mLidarLogVersionNumber = 2;
                mLidarLogFile = files[i];
                continue;
            }
            if(strstr(files[i].c_str(), "global_info_lidar") != NULL)
            {
                mLidarLogVersionNumber = 1;
                mLidarLogFile = files[i];
                continue;
            }

        }
        if(mDataLogFile.empty() == false)
        {
            result = true;
            mDataReaderThread.CreateThread(GlobalInfoLogReader::DataReaderThread, this);
            if(mDisableLidarPlaybackFlag == false)
            {
                mLaserReaderThread.CreateThread(GlobalInfoLogReader::LaserReaderThread, this);
            }
            CxUtils::SleepMs(500);
        }
    }

    return result;
}


////////////////////////////////////////////////////////////////////////////////////
///
///   \brief Set the rate of playback to speed things up, but be careful, and
///          set value before playback starts.
///
///   \param[in] rate Playback rate, 1x, 2x, 3x, etc.
///
////////////////////////////////////////////////////////////////////////////////////
void GlobalInfoLogReader::SetPlaybackRate(const int rate)
{
    if(mDataReaderThread.IsThreadActive() == false && rate >= 0)
    {
        mPlaybackRate = rate;
    }
}


////////////////////////////////////////////////////////////////////////////////////
///
///   \brief Set the time to begin reading from log (used to skip to later
///          point in file).
///
///   \param[in] startTime Time in log file (UTC)
///
////////////////////////////////////////////////////////////////////////////////////
void GlobalInfoLogReader::SetLogStartTime(const CxUtils::Time& startTime)
{
    if(mDataReaderThread.IsThreadActive() == false)
    {
        mLogStartTime = startTime;
    }
}


////////////////////////////////////////////////////////////////////////////////////
///
///   \brief Stops log playback.
///
////////////////////////////////////////////////////////////////////////////////////
void GlobalInfoLogReader::Shutdown()
{
    mDataReaderThread.StopThread();
    mDataReaderThread.KillThread();
    mLaserReaderThread.StopThread();
    mLaserReaderThread.KillThread();
    mDirectory.clear();
    mDataLogFile.clear();
    mLidarLogFile.clear();
}


/** Thread to load Log data. */
void GlobalInfoLogReader::DataReaderThread(void* args)
{
    GlobalInfoLogReader* reader = (GlobalInfoLogReader*)args;
    FILE* logFile = NULL;
    int frameNumber = -1;
    std::vector<std::string> labels;
    std::vector<std::string> strippedLabels;
    std::map<std::string, unsigned int> frameNumbers;
    unsigned int delayMs = 0;
    CxUtils::Time prevLogTime;
    bool firstRunFlag = true;
    CxUtils::Time logTime;
    std::map<std::string, int> framesLoaded;
    while(reader && reader->mDataReaderThread.QuitThreadFlag() == false)
    {
        CxUtils::Time timestamp;
        if(reader->mpGlobalInfo)
        {
            if(reader->mPauseFlag == true)
            {
                std::cout << "Playback Paused at:  " << logTime.ToString() << std::endl;
                CxUtils::SleepMs(100);
                continue;
            }
            bool haveData = false;
            if(logFile == NULL && reader->mDataLogFile.empty() == false)
            {
                logFile = fopen(reader->mDataLogFile.c_str(), "rt");
                if(logFile == NULL)
                {
                    std::cout << "GlobalInfoLogReader - Failed to Open File: " << reader->mDataLogFile << std::endl;
                    break;
                }
            }

            // If log file open, try get data.
            std::vector<std::string> data;
            if(logFile)
            {
                // If we hit the end of file, break, or rewind.
                if(feof(logFile))
                {
                    if(reader->mLoopData)
                    {
                        rewind(logFile);
                        reader->mRewindThreadCount = 0;
                        reader->mRewindFlag = true;
                        while(reader->mRewindThreadCount < 1)
                        {
                            CxUtils::SleepMs(1);
                        }
                        reader->mRewindFlag = false;
                        // Read column headers for version 1 format.
                        if(reader->mLogVersionNumber == 1)
                        {
                            CxUtils::FileIO::ParseDelimitedLine(logFile, labels, ',');
                        }
                        frameNumber = -1;
                    }
                    else
                    {
                        break;
                    }
                }
                // Read a line of data from the file.
                bool isOK = false;
                if(CxUtils::FileIO::ParseDelimitedLine(logFile, data, ',') > 1)
                {
                    haveData = true;
                    if(reader->mLogVersionNumber == 2)
                    {
                        timestamp.FromString(data[1]);
                    }
                    logTime = timestamp;
                    reader->mLogMutex.Lock();
                    reader->mLogTime = timestamp;
                    reader->mLogMutex.Unlock();
                    //std::cout << "CurrTime" << timestamp.ToMs() << "Start time " << reader->mLogStartTime.ToMs() << std::endl;
                    if(timestamp.ToMs() < reader->mLogStartTime.ToMs())
                    {
                        continue;
                    }
                    if(reader->mLogVersionNumber == 2)
                    {
                        unsigned int element = 2;
                        while(element < (unsigned int)data.size())
                        {
                            std::string label = data[element];
                            std::string type = data[element + 1];
                            std::string value = data[element + 2];
                            element += 3;
                            if(type == "[Double]")
                            {
                                reader->mpGlobalInfo->SetInfo(label, (double)atof(value.c_str()));
                            }
                            else if(type == "[Int]")
                            {
                                reader->mpGlobalInfo->SetInfo(label, (int)atoi(value.c_str()));
                            }
                            else if(type == "[Bool]")
                            {
                                reader->mpGlobalInfo->SetInfo(label, ((int)atof(value.c_str())) > 0 ? true : false);
                            }
                            else if(type == "[Frame Number]")
                            {
                                // Try load image file.
                                int frameNumber = (int)atoi(value.c_str());

                                std::map<std::string, std::map<int, std::string> >::iterator cam;

                                if(framesLoaded.find(label) == framesLoaded.end())
                                {
                                    framesLoaded[label] = -1;
                                }

                                int prevLoadedNumber = framesLoaded[label];
                                // Generate path to filename.
                                std::stringstream imageFilename;                    // Output filename for image
                                std::stringstream imageFilenameOld;                    // Output filename for image
                                imageFilename << reader->mDirectory << "/" << label << "/";
                                imageFilenameOld << reader->mDirectory << "/" << label << "/";
                                imageFilename << std::setfill('0') << std::setw(8) << frameNumber << ".png";
                                imageFilenameOld << std::setfill('0') << std::setw(6) << frameNumber << ".png";
                                if(frameNumber != prevLoadedNumber)
                                {
                                    // Load the image.
                                    IplImage* frame = cvLoadImage(imageFilename.str().c_str());
                                    if(frame == NULL)
                                    {
                                        //std::cout << "LOading Old style frame " << imageFilenameOld.str() << std::endl;

                                        frame = cvLoadImage(imageFilenameOld.str().c_str());
                                    }
                                    if(frame)
                                    {
                                        framesLoaded[label] = frameNumber;
                                        reader->mpGlobalInfo->SetInfo(label, frame);
                                        cvReleaseImage(&frame);
                                    }
                                }
                            }
                        } // Loop through data
                    } // End format version 2

                    // Calculate delay between records in file.
                    if(delayMs == 0 && !firstRunFlag)
                    {
                        delayMs = (unsigned int)(timestamp.ToMs() - prevLogTime.ToMs());
                        delayMs = (unsigned int)(1.0*delayMs/reader->mPlaybackRate);
                    }
                    firstRunFlag = false;
                    prevLogTime = timestamp;
                }
            }

            // Sleep to maintiain log playback in realtime.
            CxUtils::SleepMs(delayMs);
        }
        else
        {
            break;
        }
    }

}

/** Thread to load LIDAR data. */
void GlobalInfoLogReader::LaserReaderThread(void* args)
{
    GlobalInfoLogReader* reader = (GlobalInfoLogReader*)args;
    FILE* lidarFile = NULL;
    unsigned int delayMs = 0;
    CxUtils::Time prevLogTime;
    bool firstRunFlag = true;

    while(reader && reader->mDataReaderThread.QuitThreadFlag() == false)
    {
        if(reader->mpGlobalInfo)
        {
            if(reader->mPauseFlag == true)
            {
                //std::cout << "PAUSE!\n";
                CxUtils::SleepMs(100);
                continue;
            }

            if(lidarFile == NULL && reader->mLidarLogFile.empty() == false)
            {
                lidarFile = fopen(reader->mLidarLogFile.c_str(), "rt");
            }

            // If log file open, try get data.
            std::vector<std::string> data;

            //  Read LIDAR Data.
            if(lidarFile)
            {
                if(feof(lidarFile) || reader->mRewindFlag)
                {
                    if(reader->mLoopData)
                    {
                        rewind(lidarFile);
                        reader->mRewindThreadCount++;
                        while(reader->mRewindFlag &&
                              reader->mDataReaderThread.QuitThreadFlag() == false)
                        {

                        }
                    }
                    else
                    {
                        break;
                    }

                }
                if(CxUtils::FileIO::ParseDelimitedLine(lidarFile, data, ',') >= 4)
                {
                    if(reader->mLidarLogVersionNumber == 2 && data.size() >= 2)
                    {
                        // Read the time stamp.
                        CxUtils::Time timestamp;
                        timestamp.FromString(data[1]);
                        if(timestamp >= reader->mLogStartTime)
                        {
                            CxUtils::Time logTimeCopy;
                            reader->mLogMutex.Lock();
                            logTimeCopy = reader->mLogTime;
                            reader->mLogMutex.Unlock();
                            while(timestamp > logTimeCopy && reader->mLaserReaderThread.QuitThreadFlag() == false)
                            {
                                reader->mLogMutex.Lock();
                                logTimeCopy = reader->mLogTime;
                                reader->mLogMutex.Unlock();
                                if(reader->mRewindFlag)
                                {
                                    break;
                                }
                                CxUtils::SleepMs(1);
                            }
                            if(timestamp < logTimeCopy && logTimeCopy - timestamp > .500)
                            {
                                continue;
                            }
                            int numberOfLasers = atoi(data[2].c_str());
                            int position = 2;
                            for(int i = 0; i < numberOfLasers; i++)
                            {
                                if(data.size() - position >= 2)
                                {
                                    std::string laserName = data[++position];
                                    int numPoints = atoi(data[++position].c_str());
                                    if((unsigned int)(data.size() - position) >= (unsigned int)(numPoints*3))
                                    {
                                        position++; // Go to start of data points.
                                        CxUtils::Point3D::List scan;
                                        for(int p = 0; p < numPoints; p++)
                                        {
                                            scan.push_back(CxUtils::Point3D(atof(data[position].c_str()),
                                                                            atof(data[position+1].c_str()),
                                                                            atof(data[position+2].c_str())));
                                            position += 3;
                                        }
                                        if(scan.size() > 0)
                                        {
                                            // Save results out.
                                            reader->mpGlobalInfo->SetInfo(laserName, scan);
                                        }
                                    }
                                } // For an entire scan.
                            } // For each laser logged

                            // Calculate delay between records in file.
                            if(delayMs == 0 && !firstRunFlag)
                            {
                                delayMs = (unsigned int)(timestamp.ToMs() - prevLogTime.ToMs());
                            }
                            firstRunFlag = false;
                            prevLogTime = timestamp;
                            // Sleep to maintiain log playback in realtime.
                            CxUtils::SleepMs(delayMs);
                        }
                    }
                }
            }

            CxUtils::SleepMs(1);
        }
        else
        {
            break;
        }
    }

}


/*  End of File */
